diff --git a/lib/Socket/Client/websocket.js b/lib/Socket/Client/websocket.js
index 975b9f96124a8518bb75ff27989a85b08daa2f96..fc6bfd56d640baefe0d873f0f7d841d4d26a9d5d 100644
--- a/lib/Socket/Client/websocket.js
+++ b/lib/Socket/Client/websocket.js
@@ -30,7 +30,7 @@ export class WebSocketClient extends AbstractSocketClient {
             agent: this.config.agent
         });
         this.socket.setMaxListeners(0);
-        const events = ['close', 'error', 'upgrade', 'message', 'open', 'ping', 'pong', 'unexpected-response'];
+        const events = ['close', 'error', 'message', 'open', 'ping', 'pong'];
         for (const event of events) {
             this.socket?.on(event, (...args) => this.emit(event, ...args));
         }
diff --git a/lib/Socket/socket.js b/lib/Socket/socket.js
index 62276fc35574114b3707d5de417252eb86967d1a..126a0ae6a7c52dd7bce44cc08ca9fa81d3a66d0b 100644
--- a/lib/Socket/socket.js
+++ b/lib/Socket/socket.js
@@ -235,6 +235,9 @@ export const makeSocket = (config) => {
     let closed = false;
     /** log & process any unexpected errors */
     const onUnexpectedError = (err, msg) => {
+        if (!ws.isOpen) {
+            return;
+        }
         logger.error({ err }, `unexpected error in '${msg}'`);
     };
     /** await the next incoming message */
diff --git a/lib/Types/Message.d.ts b/lib/Types/Message.d.ts
index df860a7fa07ba1677dcc26bd0397bbbaa8b20edf..643c0229a7352733b83d4843ade7cf32f9003577 100644
--- a/lib/Types/Message.d.ts
+++ b/lib/Types/Message.d.ts
@@ -131,7 +131,7 @@ export type AnyMediaMessageContent = (({
     isAnimated?: boolean;
 } & WithDimensions) | ({
     document: WAMediaUpload;
-    mimetype: string;
+    mimetype?: string;
     fileName?: string;
     caption?: string;
 } & Contextable)) & {
@@ -239,6 +239,7 @@ export type MiscMessageGenerationOptions = MinimalRelayOptions & {
     font?: number;
     /** if it is broadcast */
     broadcast?: boolean;
+    waveformProxy?: Buffer | null;
 };
 export type MessageGenerationOptionsFromContent = MiscMessageGenerationOptions & {
     userJid: string;
diff --git a/lib/Utils/auth-utils.js b/lib/Utils/auth-utils.js
index ca168e0eef19f9f9bc65a758a39d35c81e1f7497..740b50288a08e5febad561101bd4a9b5ce4e85b3 100644
--- a/lib/Utils/auth-utils.js
+++ b/lib/Utils/auth-utils.js
@@ -200,6 +200,16 @@ export const addTransactionCapability = (state, logger, { maxCommitRetries, dela
                 }
             }
         },
+        clear: () => {
+            if (isInTransaction()) {
+                logger.trace('clearing cache in transaction');
+                transactionCache = {};
+                mutations = {};
+            }
+            else {
+                return state.clear();
+            }
+        },
         isInTransaction,
         transaction: async (work, key) => {
             const existing = txStorage.getStore();
diff --git a/lib/Utils/link-preview.js b/lib/Utils/link-preview.js
index e850e6b544017cb9856718ad16531039db0d61a2..833459cb9a14426fee414c4f343acbacbdf109ea 100644
--- a/lib/Utils/link-preview.js
+++ b/lib/Utils/link-preview.js
@@ -1,6 +1,40 @@
 import { prepareWAMessageMedia } from './messages.js';
 import { extractImageThumb, getHttpStream } from './messages-media.js';
 const THUMBNAIL_WIDTH_PX = 192;
+const isYouTubeUrl = (url) => {
+    return /(?:youtube\.com\/watch\?v=|youtu\.be\/)/.test(url);
+};
+const getVideoId = (url) => {
+    const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&]+)/);
+    return match ? match[1] : null;
+};
+const getYouTubeLinkPreview = async (videoUrl) => {
+    const videoId = getVideoId(videoUrl);
+    if (!videoId) {
+        throw new Error('Invalid YouTube URL');
+    }
+    const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(videoUrl)}&format=json`;
+    const response = await fetch(oembedUrl);
+    if (!response.ok) {
+        throw new Error(`Failed to fetch YouTube oEmbed data: ${response.statusText}`);
+    }
+    const data = await response.json();
+    return {
+        url: videoUrl,
+        title: data.title,
+        siteName: 'YouTube',
+        description: `${data.author_name}`,
+        mediaType: 'video.other',
+        contentType: 'text/html; charset=utf-8',
+        images: [
+            `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,
+            `https://img.youtube.com/vi/${videoId}/sddefault.jpg`,
+            data.thumbnail_url
+        ],
+        videos: [],
+        favicons: ['https://www.youtube.com/favicon.ico']
+    };
+};
 /** Fetches an image and generates a thumbnail for it */
 const getCompressedJpegThumbnail = async (url, { thumbnailWidth, fetchOpts }) => {
     const stream = await getHttpStream(url, fetchOpts);
@@ -18,35 +52,39 @@ export const getUrlInfo = async (text, opts = {
     fetchOpts: { timeout: 3000 }
 }) => {
     try {
-        // retries
-        const retries = 0;
-        const maxRetry = 5;
         const { getLinkPreview } = await import('link-preview-js');
         let previewLink = text;
         if (!text.startsWith('https://') && !text.startsWith('http://')) {
             previewLink = 'https://' + previewLink;
         }
-        const info = await getLinkPreview(previewLink, {
-            ...opts.fetchOpts,
-            followRedirects: 'follow',
-            handleRedirects: (baseURL, forwardedURL) => {
-                const urlObj = new URL(baseURL);
-                const forwardedURLObj = new URL(forwardedURL);
-                if (retries >= maxRetry) {
-                    return false;
-                }
-                if (forwardedURLObj.hostname === urlObj.hostname ||
-                    forwardedURLObj.hostname === 'www.' + urlObj.hostname ||
-                    'www.' + forwardedURLObj.hostname === urlObj.hostname) {
-                    retries + 1;
-                    return true;
-                }
-                else {
-                    return false;
-                }
-            },
-            headers: opts.fetchOpts?.headers
-        });
+        let info;
+        if (isYouTubeUrl(previewLink)) {
+            info = await getYouTubeLinkPreview(previewLink);
+        } else {
+            const retries = 0;
+            const maxRetry = 5;
+            info = await getLinkPreview(previewLink, {
+                ...opts.fetchOpts,
+                followRedirects: 'follow',
+                handleRedirects: (baseURL, forwardedURL) => {
+                    const urlObj = new URL(baseURL);
+                    const forwardedURLObj = new URL(forwardedURL);
+                    if (retries >= maxRetry) {
+                        return false;
+                    }
+                    if (forwardedURLObj.hostname === urlObj.hostname
+                        || forwardedURLObj.hostname === 'www.' + urlObj.hostname
+                        || 'www.' + forwardedURLObj.hostname === urlObj.hostname) {
+                        retries + 1;
+                        return true;
+                    }
+                    else {
+                        return false;
+                    }
+                },
+                headers: opts.fetchOpts
+            });
+        }
         if (info && 'title' in info && info.title) {
             const [image] = info.images;
             const urlInfo = {
diff --git a/lib/Utils/messages.js b/lib/Utils/messages.js
index 17b05b84f70196c908396b7f74f9a815a1b65daf..ec3f0b05a0f5b0f94cae49ed2a555dfff9dcbe28 100644
--- a/lib/Utils/messages.js
+++ b/lib/Utils/messages.js
@@ -168,7 +168,7 @@ export const prepareWAMessageMedia = async (message, options) => {
                     logger?.debug('computed audio duration');
                 }
                 if (requiresWaveformProcessing) {
-                    uploadData.waveform = await getAudioWaveform(originalFilePath, logger);
+                    uploadData.waveform = await getAudioWaveform(options.waveformProxy || originalFilePath, logger);
                     logger?.debug('processed waveform');
                 }
                 if (requiresAudioBackground) {
