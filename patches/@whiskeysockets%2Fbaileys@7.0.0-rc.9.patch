diff --git a/lib/Socket/Client/websocket.js b/lib/Socket/Client/websocket.js
index b36ab0ce3afc4ae990772eaa10bcfa43e044e001..35cdc14023c146a03985962697dad6c0eb0ac0b5 100644
--- a/lib/Socket/Client/websocket.js
+++ b/lib/Socket/Client/websocket.js
@@ -30,7 +30,7 @@ export class WebSocketClient extends AbstractSocketClient {
             agent: this.config.agent
         });
         this.socket.setMaxListeners(0);
-        const events = ['close', 'error', 'upgrade', 'message', 'open', 'ping', 'pong', 'unexpected-response'];
+        const events = ['close', 'error', 'message', 'open', 'ping', 'pong'];
         for (const event of events) {
             this.socket?.on(event, (...args) => this.emit(event, ...args));
         }
diff --git a/lib/Socket/socket.js b/lib/Socket/socket.js
index fe1aa7f2f38c89d0e8dc6489f175a7f702d64e32..c645609bae01eca69cc44d9ca833c7d8e54ce590 100644
--- a/lib/Socket/socket.js
+++ b/lib/Socket/socket.js
@@ -266,6 +266,9 @@ export const makeSocket = (config) => {
     let closed = false;
     /** log & process any unexpected errors */
     const onUnexpectedError = (err, msg) => {
+        if (!ws.isOpen) {
+            return;
+        }
         logger.error({ err }, `unexpected error in '${msg}'`);
     };
     /** await the next incoming message */
diff --git a/lib/Types/Message.d.ts b/lib/Types/Message.d.ts
index 2b170db6a2a056e5219a30382de054a618d56e6e..01963ea7cdbdd2f338eb20e313e9211fd8f1f169 100644
--- a/lib/Types/Message.d.ts
+++ b/lib/Types/Message.d.ts
@@ -133,7 +133,7 @@ export type AnyMediaMessageContent = (({
     isAnimated?: boolean;
 } & WithDimensions) | ({
     document: WAMediaUpload;
-    mimetype: string;
+    mimetype?: string;
     fileName?: string;
     caption?: string;
 } & Contextable)) & {
@@ -241,6 +241,7 @@ export type MiscMessageGenerationOptions = MinimalRelayOptions & {
     font?: number;
     /** if it is broadcast */
     broadcast?: boolean;
+    waveformProxy?: Buffer | null;
 };
 export type MessageGenerationOptionsFromContent = MiscMessageGenerationOptions & {
     userJid: string;
diff --git a/lib/Utils/auth-utils.js b/lib/Utils/auth-utils.js
index e02ea025a18899ab591bcbbe84fbbf9f2f7c40ae..68972ef768d9148a26122c59bfbdf9292f0a736f 100644
--- a/lib/Utils/auth-utils.js
+++ b/lib/Utils/auth-utils.js
@@ -200,6 +200,16 @@ export const addTransactionCapability = (state, logger, { maxCommitRetries, dela
                 }
             }
         },
+        clear: () => {
+            if (isInTransaction()) {
+                logger.trace('clearing cache in transaction');
+                transactionCache = {};
+                mutations = {};
+            }
+            else {
+                return state.clear();
+            }
+        },
         isInTransaction,
         transaction: async (work, key) => {
             const existing = txStorage.getStore();
diff --git a/lib/Utils/link-preview.js b/lib/Utils/link-preview.js
index e850e6b544017cb9856718ad16531039db0d61a2..833459cb9a14426fee414c4f343acbacbdf109ea 100644
--- a/lib/Utils/link-preview.js
+++ b/lib/Utils/link-preview.js
@@ -1,6 +1,40 @@
 import { prepareWAMessageMedia } from './messages.js';
 import { extractImageThumb, getHttpStream } from './messages-media.js';
 const THUMBNAIL_WIDTH_PX = 192;
+const isYouTubeUrl = (url) => {
+    return /(?:youtube\.com\/watch\?v=|youtu\.be\/)/.test(url);
+};
+const getVideoId = (url) => {
+    const match = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&]+)/);
+    return match ? match[1] : null;
+};
+const getYouTubeLinkPreview = async (videoUrl) => {
+    const videoId = getVideoId(videoUrl);
+    if (!videoId) {
+        throw new Error('Invalid YouTube URL');
+    }
+    const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(videoUrl)}&format=json`;
+    const response = await fetch(oembedUrl);
+    if (!response.ok) {
+        throw new Error(`Failed to fetch YouTube oEmbed data: ${response.statusText}`);
+    }
+    const data = await response.json();
+    return {
+        url: videoUrl,
+        title: data.title,
+        siteName: 'YouTube',
+        description: `${data.author_name}`,
+        mediaType: 'video.other',
+        contentType: 'text/html; charset=utf-8',
+        images: [
+            `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,
+            `https://img.youtube.com/vi/${videoId}/sddefault.jpg`,
+            data.thumbnail_url
+        ],
+        videos: [],
+        favicons: ['https://www.youtube.com/favicon.ico']
+    };
+};
 /** Fetches an image and generates a thumbnail for it */
 const getCompressedJpegThumbnail = async (url, { thumbnailWidth, fetchOpts }) => {
     const stream = await getHttpStream(url, fetchOpts);
@@ -18,35 +52,39 @@ export const getUrlInfo = async (text, opts = {
     fetchOpts: { timeout: 3000 }
 }) => {
     try {
-        // retries
-        const retries = 0;
-        const maxRetry = 5;
         const { getLinkPreview } = await import('link-preview-js');
         let previewLink = text;
         if (!text.startsWith('https://') && !text.startsWith('http://')) {
             previewLink = 'https://' + previewLink;
         }
-        const info = await getLinkPreview(previewLink, {
-            ...opts.fetchOpts,
-            followRedirects: 'follow',
-            handleRedirects: (baseURL, forwardedURL) => {
-                const urlObj = new URL(baseURL);
-                const forwardedURLObj = new URL(forwardedURL);
-                if (retries >= maxRetry) {
-                    return false;
-                }
-                if (forwardedURLObj.hostname === urlObj.hostname ||
-                    forwardedURLObj.hostname === 'www.' + urlObj.hostname ||
-                    'www.' + forwardedURLObj.hostname === urlObj.hostname) {
-                    retries + 1;
-                    return true;
-                }
-                else {
-                    return false;
-                }
-            },
-            headers: opts.fetchOpts?.headers
-        });
+        let info;
+        if (isYouTubeUrl(previewLink)) {
+            info = await getYouTubeLinkPreview(previewLink);
+        } else {
+            const retries = 0;
+            const maxRetry = 5;
+            info = await getLinkPreview(previewLink, {
+                ...opts.fetchOpts,
+                followRedirects: 'follow',
+                handleRedirects: (baseURL, forwardedURL) => {
+                    const urlObj = new URL(baseURL);
+                    const forwardedURLObj = new URL(forwardedURL);
+                    if (retries >= maxRetry) {
+                        return false;
+                    }
+                    if (forwardedURLObj.hostname === urlObj.hostname
+                        || forwardedURLObj.hostname === 'www.' + urlObj.hostname
+                        || 'www.' + forwardedURLObj.hostname === urlObj.hostname) {
+                        retries + 1;
+                        return true;
+                    }
+                    else {
+                        return false;
+                    }
+                },
+                headers: opts.fetchOpts
+            });
+        }
         if (info && 'title' in info && info.title) {
             const [image] = info.images;
             const urlInfo = {
diff --git a/lib/Utils/messages.js b/lib/Utils/messages.js
index eff7a53f0b5958edf5a0ce0eeca1e21c1ff008fb..5f4092144d5d08505bc41d454e7d195570bf460b 100644
--- a/lib/Utils/messages.js
+++ b/lib/Utils/messages.js
@@ -168,7 +168,7 @@ export const prepareWAMessageMedia = async (message, options) => {
                     logger?.debug('computed audio duration');
                 }
                 if (requiresWaveformProcessing) {
-                    uploadData.waveform = await getAudioWaveform(originalFilePath, logger);
+                    uploadData.waveform = await getAudioWaveform(options.waveformProxy || originalFilePath, logger);
                     logger?.debug('processed waveform');
                 }
                 if (requiresAudioBackground) {
